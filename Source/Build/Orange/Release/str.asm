; Listing generated by Microsoft (R) Optimizing Compiler Version 19.30.30709.0 

	TITLE	C:\Users\namel\Documents\GitHub\Postal1\Source\Build\Orange\Release\str.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?rspStricmp@@YAFPBD0@Z				; rspStricmp
PUBLIC	?rspStrnicmp@@YAFPBD0I@Z			; rspStrnicmp
_DATA	SEGMENT
?ms_asUpper2Lower@@3PAFA DW 00H				; ms_asUpper2Lower
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0cH
	DW	0dH
	DW	0eH
	DW	0fH
	DW	010H
	DW	011H
	DW	012H
	DW	013H
	DW	014H
	DW	015H
	DW	016H
	DW	017H
	DW	018H
	DW	019H
	DW	01aH
	DW	01bH
	DW	01cH
	DW	01dH
	DW	01eH
	DW	01fH
	DW	020H
	DW	021H
	DW	022H
	DW	023H
	DW	024H
	DW	025H
	DW	026H
	DW	027H
	DW	028H
	DW	029H
	DW	02aH
	DW	02bH
	DW	02cH
	DW	02dH
	DW	02eH
	DW	02fH
	DW	030H
	DW	031H
	DW	032H
	DW	033H
	DW	034H
	DW	035H
	DW	036H
	DW	037H
	DW	038H
	DW	039H
	DW	03aH
	DW	03bH
	DW	03cH
	DW	03dH
	DW	03eH
	DW	03fH
	DW	040H
	DW	061H
	DW	062H
	DW	063H
	DW	064H
	DW	065H
	DW	066H
	DW	067H
	DW	068H
	DW	069H
	DW	06aH
	DW	06bH
	DW	06cH
	DW	06dH
	DW	06eH
	DW	06fH
	DW	070H
	DW	071H
	DW	072H
	DW	073H
	DW	074H
	DW	075H
	DW	076H
	DW	077H
	DW	078H
	DW	079H
	DW	07aH
	DW	05bH
	DW	05cH
	DW	05dH
	DW	05eH
	DW	05fH
	DW	060H
	DW	061H
	DW	062H
	DW	063H
	DW	064H
	DW	065H
	DW	066H
	DW	067H
	DW	068H
	DW	069H
	DW	06aH
	DW	06bH
	DW	06cH
	DW	06dH
	DW	06eH
	DW	06fH
	DW	070H
	DW	071H
	DW	072H
	DW	073H
	DW	074H
	DW	075H
	DW	076H
	DW	077H
	DW	078H
	DW	079H
	DW	07aH
	DW	07bH
	DW	07cH
	DW	07dH
	DW	07eH
	DW	07fH
	DW	080H
	DW	081H
	DW	082H
	DW	083H
	DW	084H
	DW	085H
	DW	086H
	DW	087H
	DW	088H
	DW	089H
	DW	08aH
	DW	08bH
	DW	08cH
	DW	08dH
	DW	08eH
	DW	08fH
	DW	090H
	DW	091H
	DW	092H
	DW	093H
	DW	094H
	DW	095H
	DW	096H
	DW	097H
	DW	098H
	DW	099H
	DW	09aH
	DW	09bH
	DW	09cH
	DW	09dH
	DW	09eH
	DW	09fH
	DW	0a0H
	DW	0a1H
	DW	0a2H
	DW	0a3H
	DW	0a4H
	DW	0a5H
	DW	0a6H
	DW	0a7H
	DW	0a8H
	DW	0a9H
	DW	0aaH
	DW	0abH
	DW	0acH
	DW	0adH
	DW	0aeH
	DW	0afH
	DW	0b0H
	DW	0b1H
	DW	0b2H
	DW	0b3H
	DW	0b4H
	DW	0b5H
	DW	0b6H
	DW	0b7H
	DW	0b8H
	DW	0b9H
	DW	0baH
	DW	0bbH
	DW	0bcH
	DW	0bdH
	DW	0beH
	DW	0bfH
	DW	0c0H
	DW	0c1H
	DW	0c2H
	DW	0c3H
	DW	0c4H
	DW	0c5H
	DW	0c6H
	DW	0c7H
	DW	0c8H
	DW	0c9H
	DW	0caH
	DW	0cbH
	DW	0ccH
	DW	0cdH
	DW	0ceH
	DW	0cfH
	DW	0d0H
	DW	0d1H
	DW	0d2H
	DW	0d3H
	DW	0d4H
	DW	0d5H
	DW	0d6H
	DW	0d7H
	DW	0d8H
	DW	0d9H
	DW	0daH
	DW	0dbH
	DW	0dcH
	DW	0ddH
	DW	0deH
	DW	0dfH
	DW	0e0H
	DW	0e1H
	DW	0e2H
	DW	0e3H
	DW	0e4H
	DW	0e5H
	DW	0e6H
	DW	0e7H
	DW	0e8H
	DW	0e9H
	DW	0eaH
	DW	0ebH
	DW	0ecH
	DW	0edH
	DW	0eeH
	DW	0efH
	DW	0f0H
	DW	0f1H
	DW	0f2H
	DW	0f3H
	DW	0f4H
	DW	0f5H
	DW	0f6H
	DW	0f7H
	DW	0f8H
	DW	0f9H
	DW	0faH
	DW	0fbH
	DW	0fcH
	DW	0fdH
	DW	0feH
	DW	0ffH
_DATA	ENDS
; Function compile flags: /Ogtp
; File C:\Users\namel\Documents\GitHub\Postal1\Source\RSPiX\Src\ORANGE\str\str.cpp
;	COMDAT ?rspStrnicmp@@YAFPBD0I@Z
_TEXT	SEGMENT
_pszStr1$ = 8						; size = 4
_pszStr2$ = 12						; size = 4
_count$ = 16						; size = 4
?rspStrnicmp@@YAFPBD0I@Z PROC				; rspStrnicmp, COMDAT

; 407  : 	{

	push	ebp
	mov	ebp, esp

; 408  : 	ASSERT(count >= 0);
; 409  : 
; 410  : 	short	sRes	= 0;	// Assume equivalent.
; 411  : 
; 412  : 	while (*pszStr1 != '\0' && *pszStr2 != '\0' && sRes == 0 && count--)

	mov	edx, DWORD PTR _count$[ebp]
	xor	ecx, ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _pszStr2$[ebp]
	push	edi
	mov	edi, DWORD PTR _pszStr1$[ebp]
	mov	bh, BYTE PTR [edi]
	test	bh, bh
	je	SHORT $LN15@rspStrnicm
$LL2@rspStrnicm:
	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN3@rspStrnicm
	test	cx, cx
	jne	SHORT $LN17@rspStrnicm
	mov	eax, edx
	dec	edx
	test	eax, eax
	je	SHORT $LN15@rspStrnicm

; 413  : 		{
; 414  : 		sRes	= ms_asUpper2Lower[*pszStr1++] - ms_asUpper2Lower[*pszStr2++];

	movsx	eax, bh
	inc	edi
	movsx	ecx, bl
	inc	esi
	mov	ax, WORD PTR ?ms_asUpper2Lower@@3PAFA[eax*2]
	sub	ax, WORD PTR ?ms_asUpper2Lower@@3PAFA[ecx*2]
	mov	bh, BYTE PTR [edi]
	movzx	ecx, ax
	test	bh, bh
	jne	SHORT $LL2@rspStrnicm
$LN3@rspStrnicm:

; 415  : 		}
; 416  : 
; 417  : 	// If identical . . .
; 418  : 	if (sRes == 0 && count != 0)

	test	cx, cx
	jne	SHORT $LN17@rspStrnicm
$LN15@rspStrnicm:
	test	edx, edx
	je	SHORT $LN17@rspStrnicm

; 419  : 		{
; 420  : 		// If first string ended prematurely . . .
; 421  : 		if (*pszStr1 == '\0' && *pszStr2 != '\0')

	cmp	BYTE PTR [edi], 0
	mov	al, BYTE PTR [esi]
	jne	SHORT $LN14@rspStrnicm
	test	al, al
	je	SHORT $LN17@rspStrnicm

; 427  : 			{
; 428  : 			sRes	= 1;
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	return sRes;
; 433  : 	}

	pop	edi
	pop	esi
	mov	eax, -1
	pop	ebx
	pop	ebp
	ret	0
$LN14@rspStrnicm:

; 422  : 			{
; 423  : 			sRes	= -1;
; 424  : 			}
; 425  : 		// Else, if second string ended prematurely . . .
; 426  : 		else if (*pszStr1 != '\0' && *pszStr2 == '\0')

	test	al, al
	mov	edx, 1
	cmove	ecx, edx
$LN17@rspStrnicm:

; 427  : 			{
; 428  : 			sRes	= 1;
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	return sRes;
; 433  : 	}

	pop	edi
	pop	esi
	mov	ax, cx
	pop	ebx
	pop	ebp
	ret	0
?rspStrnicmp@@YAFPBD0I@Z ENDP				; rspStrnicmp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\namel\Documents\GitHub\Postal1\Source\RSPiX\Src\ORANGE\str\str.cpp
;	COMDAT ?rspStricmp@@YAFPBD0@Z
_TEXT	SEGMENT
_pszStr1$ = 8						; size = 4
_pszStr2$ = 12						; size = 4
?rspStricmp@@YAFPBD0@Z PROC				; rspStricmp, COMDAT

; 364  : 	{

	push	ebp
	mov	ebp, esp

; 365  : 	short	sRes	= 0;	// Assume equivalent.
; 366  : 
; 367  : 	while (*pszStr1 != '\0' && *pszStr2 != '\0' && sRes == 0)

	mov	edx, DWORD PTR _pszStr2$[ebp]
	xor	eax, eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _pszStr1$[ebp]
	mov	bl, BYTE PTR [esi]
	test	bl, bl
	je	SHORT $LN15@rspStricmp
$LL2@rspStricmp:
	mov	cl, BYTE PTR [edx]
	test	cl, cl
	je	SHORT $LN3@rspStricmp
	test	ax, ax
	jne	SHORT $LN7@rspStricmp

; 368  : 		{
; 369  : 		sRes	= ms_asUpper2Lower[*pszStr1++] - ms_asUpper2Lower[*pszStr2++];

	movsx	eax, bl
	inc	esi
	movsx	ecx, cl
	inc	edx
	mov	ax, WORD PTR ?ms_asUpper2Lower@@3PAFA[eax*2]
	sub	ax, WORD PTR ?ms_asUpper2Lower@@3PAFA[ecx*2]
	mov	bl, BYTE PTR [esi]
	movzx	eax, ax
	test	bl, bl
	jne	SHORT $LL2@rspStricmp
$LN3@rspStricmp:

; 370  : 		}
; 371  : 
; 372  : 	// If identical . . .
; 373  : 	if (sRes == 0)

	test	ax, ax
	jne	SHORT $LN7@rspStricmp
$LN15@rspStricmp:

; 374  : 		{
; 375  : 		// If first string ended prematurely . . .
; 376  : 		if (*pszStr1 == '\0' && *pszStr2 != '\0')

	cmp	BYTE PTR [esi], 0
	mov	cl, BYTE PTR [edx]
	jne	SHORT $LN14@rspStricmp
	test	cl, cl
	je	SHORT $LN7@rspStricmp

; 377  : 			{
; 378  : 			sRes	= -1;

	pop	esi
	or	eax, -1

; 382  : 			{
; 383  : 			sRes	= 1;
; 384  : 			}
; 385  : 		}
; 386  : 
; 387  : 	return sRes;
; 388  : 	}

	pop	ebx
	pop	ebp
	ret	0
$LN14@rspStricmp:

; 379  : 			}
; 380  : 		// Else, if second string ended prematurely . . .
; 381  : 		else if (*pszStr1 != '\0' && *pszStr2 == '\0')

	test	cl, cl
	mov	edx, 1
	cmove	eax, edx
$LN7@rspStricmp:

; 382  : 			{
; 383  : 			sRes	= 1;
; 384  : 			}
; 385  : 		}
; 386  : 
; 387  : 	return sRes;
; 388  : 	}

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
?rspStricmp@@YAFPBD0@Z ENDP				; rspStricmp
_TEXT	ENDS
END
